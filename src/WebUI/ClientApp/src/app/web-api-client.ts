//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ICommentClient {
    get(query: string | undefined): Observable<GetCommentQueryVM>;
    create(command: CreateCommentCommand): Observable<string>;
    update(id: string, command: UpdateCommentCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class CommentClient implements ICommentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query: string | undefined): Observable<GetCommentQueryVM> {
        let url_ = this.baseUrl + "/api/Comment?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCommentQueryVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCommentQueryVM>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetCommentQueryVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCommentQueryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateCommentCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Comment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, command: UpdateCommentCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Comment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Comment/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPointClient {
    get(query: string | undefined): Observable<GetPointQueryVM>;
    create(command: CreatePointCommand): Observable<string>;
    update(id: string, command: UpdatePointCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class PointClient implements IPointClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query: string | undefined): Observable<GetPointQueryVM> {
        let url_ = this.baseUrl + "/api/Point?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPointQueryVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPointQueryVM>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetPointQueryVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPointQueryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreatePointCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Point";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, command: UpdatePointCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Point/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Point/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IPointTemplateClient {
    get(query: string | undefined): Observable<GetPointTemplateQueryVM>;
    create(command: CreatePointTemplateCommand): Observable<string>;
    update(id: string, command: UpdatePointTemplateCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class PointTemplateClient implements IPointTemplateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query: string | undefined): Observable<GetPointTemplateQueryVM> {
        let url_ = this.baseUrl + "/api/PointTemplate?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPointTemplateQueryVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPointTemplateQueryVM>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetPointTemplateQueryVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPointTemplateQueryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreatePointTemplateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/PointTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, command: UpdatePointTemplateCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PointTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/PointTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRoleClient {
    get(query: string | undefined): Observable<GetRoleQueryVM>;
    create(command: CreateRoleCommand): Observable<string>;
    update(id: string, command: UpdateRoleCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RoleClient implements IRoleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query: string | undefined): Observable<GetRoleQueryVM> {
        let url_ = this.baseUrl + "/api/Role?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleQueryVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleQueryVM>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetRoleQueryVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleQueryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateRoleCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Role";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, command: UpdateRoleCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Role/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRoleSourceClient {
    create(command: CreateRoleSourceCommand): Observable<string>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RoleSourceClient implements IRoleSourceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateRoleSourceCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/RoleSource";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RoleSource/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRoleTemplateClient {
    create(command: CreateRoleTemplateCommand): Observable<string>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class RoleTemplateClient implements IRoleTemplateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateRoleTemplateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/RoleTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/RoleTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISourceClient {
    get(query: string | undefined): Observable<GetSourceQueryVM>;
    create(command: CreateSourceCommand): Observable<string>;
    update(id: string, command: UpdateSourceCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class SourceClient implements ISourceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query: string | undefined): Observable<GetSourceQueryVM> {
        let url_ = this.baseUrl + "/api/Source?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSourceQueryVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSourceQueryVM>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetSourceQueryVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSourceQueryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateSourceCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Source";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, command: UpdateSourceCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Source/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITemplateClient {
    get(query: string | undefined): Observable<GetTemplateQueryVM>;
    create(command: CreateTemplateCommand): Observable<string>;
    update(id: string, command: UpdateTemplateCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TemplateClient implements ITemplateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query: string | undefined): Observable<GetTemplateQueryVM> {
        let url_ = this.baseUrl + "/api/Template?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTemplateQueryVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTemplateQueryVM>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetTemplateQueryVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTemplateQueryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateTemplateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/Template";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, command: UpdateTemplateCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Template/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Template/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUploadedFileClient {
    get(query: string | undefined): Observable<GetFileQueryVM>;
    create(command: CreateFileCommand): Observable<string>;
    update(id: string, command: UpdateFileCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UploadedFileClient implements IUploadedFileClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query: string | undefined): Observable<GetFileQueryVM> {
        let url_ = this.baseUrl + "/api/UploadedFile?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetFileQueryVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetFileQueryVM>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetFileQueryVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetFileQueryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateFileCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/UploadedFile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, command: UpdateFileCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UploadedFile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UploadedFile/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserClient {
    get(query: string | undefined): Observable<GetUserQueryVM>;
    create(command: CreateUserCommand): Observable<string>;
    update(id: string, command: UpdateUserCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UserClient implements IUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query: string | undefined): Observable<GetUserQueryVM> {
        let url_ = this.baseUrl + "/api/User?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserQueryVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserQueryVM>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetUserQueryVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserQueryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateUserCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/User";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, command: UpdateUserCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/User/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserRequestTemplateClient {
    get(query: string | undefined): Observable<GetUserRequestTemplateQueryVM>;
    create(command: CreateUserRequestTemplateCommand): Observable<string>;
    update(id: string, command: UpdateUserRequestTemplateCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UserRequestTemplateClient implements IUserRequestTemplateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query: string | undefined): Observable<GetUserRequestTemplateQueryVM> {
        let url_ = this.baseUrl + "/api/UserRequestTemplate?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserRequestTemplateQueryVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserRequestTemplateQueryVM>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetUserRequestTemplateQueryVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserRequestTemplateQueryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateUserRequestTemplateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/UserRequestTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, command: UpdateUserRequestTemplateCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UserRequestTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UserRequestTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserRoleClient {
    create(command: CreateUserRoleCommand): Observable<string>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UserRoleClient implements IUserRoleClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateUserRoleCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/UserRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UserRole/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserRpointTemplateClient {
    get(query: string | undefined): Observable<GetUserRpointTemplateQueryVM>;
    create(command: CreateUserRpointTemplateCommand): Observable<string>;
    update(id: string, command: UpdateUserRpointTemplateCommand): Observable<FileResponse>;
    delete(id: string): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UserRpointTemplateClient implements IUserRpointTemplateClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(query: string | undefined): Observable<GetUserRpointTemplateQueryVM> {
        let url_ = this.baseUrl + "/api/UserRpointTemplate?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserRpointTemplateQueryVM>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserRpointTemplateQueryVM>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetUserRpointTemplateQueryVM> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserRpointTemplateQueryVM.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    create(command: CreateUserRpointTemplateCommand): Observable<string> {
        let url_ = this.baseUrl + "/api/UserRpointTemplate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    update(id: string, command: UpdateUserRpointTemplateCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UserRpointTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    delete(id: string): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/UserRpointTemplate/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class GetCommentQueryVM implements IGetCommentQueryVM {
    text?: string;
    commentDate?: Date;
    inverseCommentNavigation?: CommentDto[] | undefined;

    constructor(data?: IGetCommentQueryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.commentDate = _data["commentDate"] ? new Date(_data["commentDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["inverseCommentNavigation"])) {
                this.inverseCommentNavigation = [] as any;
                for (let item of _data["inverseCommentNavigation"])
                    this.inverseCommentNavigation!.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetCommentQueryVM {
        data = typeof data === 'object' ? data : {};
        let result = new GetCommentQueryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["commentDate"] = this.commentDate ? this.commentDate.toISOString() : <any>undefined;
        if (Array.isArray(this.inverseCommentNavigation)) {
            data["inverseCommentNavigation"] = [];
            for (let item of this.inverseCommentNavigation)
                data["inverseCommentNavigation"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetCommentQueryVM {
    text?: string;
    commentDate?: Date;
    inverseCommentNavigation?: CommentDto[] | undefined;
}

export class CommentDto implements ICommentDto {
    text?: string;
    commentDate?: Date;
    inverseCommentNavigation?: CommentDto[] | undefined;

    constructor(data?: ICommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.commentDate = _data["commentDate"] ? new Date(_data["commentDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["inverseCommentNavigation"])) {
                this.inverseCommentNavigation = [] as any;
                for (let item of _data["inverseCommentNavigation"])
                    this.inverseCommentNavigation!.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["commentDate"] = this.commentDate ? this.commentDate.toISOString() : <any>undefined;
        if (Array.isArray(this.inverseCommentNavigation)) {
            data["inverseCommentNavigation"] = [];
            for (let item of this.inverseCommentNavigation)
                data["inverseCommentNavigation"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICommentDto {
    text?: string;
    commentDate?: Date;
    inverseCommentNavigation?: CommentDto[] | undefined;
}

export class CreateCommentCommand implements ICreateCommentCommand {
    userId?: string;
    userRpointTemplateId?: string;
    text!: string;
    commentDate!: Date;
    inverseCommentNavigation?: CommentDto[] | undefined;

    constructor(data?: ICreateCommentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userRpointTemplateId = _data["userRpointTemplateId"];
            this.text = _data["text"];
            this.commentDate = _data["commentDate"] ? new Date(_data["commentDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["inverseCommentNavigation"])) {
                this.inverseCommentNavigation = [] as any;
                for (let item of _data["inverseCommentNavigation"])
                    this.inverseCommentNavigation!.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateCommentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateCommentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userRpointTemplateId"] = this.userRpointTemplateId;
        data["text"] = this.text;
        data["commentDate"] = this.commentDate ? this.commentDate.toISOString() : <any>undefined;
        if (Array.isArray(this.inverseCommentNavigation)) {
            data["inverseCommentNavigation"] = [];
            for (let item of this.inverseCommentNavigation)
                data["inverseCommentNavigation"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateCommentCommand {
    userId?: string;
    userRpointTemplateId?: string;
    text: string;
    commentDate: Date;
    inverseCommentNavigation?: CommentDto[] | undefined;
}

export class UpdateCommentCommand implements IUpdateCommentCommand {
    id?: string;
    text!: string;
    commentDate!: Date;
    inverseCommentNavigation?: CommentDto[] | undefined;

    constructor(data?: IUpdateCommentCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.commentDate = _data["commentDate"] ? new Date(_data["commentDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["inverseCommentNavigation"])) {
                this.inverseCommentNavigation = [] as any;
                for (let item of _data["inverseCommentNavigation"])
                    this.inverseCommentNavigation!.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateCommentCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateCommentCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["commentDate"] = this.commentDate ? this.commentDate.toISOString() : <any>undefined;
        if (Array.isArray(this.inverseCommentNavigation)) {
            data["inverseCommentNavigation"] = [];
            for (let item of this.inverseCommentNavigation)
                data["inverseCommentNavigation"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateCommentCommand {
    id?: string;
    text: string;
    commentDate: Date;
    inverseCommentNavigation?: CommentDto[] | undefined;
}

export class GetPointQueryVM implements IGetPointQueryVM {
    id?: string;
    pointName?: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;

    constructor(data?: IGetPointQueryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pointName = _data["pointName"];
            if (Array.isArray(_data["pointTemplates"])) {
                this.pointTemplates = [] as any;
                for (let item of _data["pointTemplates"])
                    this.pointTemplates!.push(PointTemplateDto.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPointQueryVM {
        data = typeof data === 'object' ? data : {};
        let result = new GetPointQueryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pointName"] = this.pointName;
        if (Array.isArray(this.pointTemplates)) {
            data["pointTemplates"] = [];
            for (let item of this.pointTemplates)
                data["pointTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPointQueryVM {
    id?: string;
    pointName?: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
}

export class PointTemplateDto implements IPointTemplateDto {
    seriesNumber?: number;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;

    constructor(data?: IPointTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.seriesNumber = _data["seriesNumber"];
            if (Array.isArray(_data["userRpointTemplates"])) {
                this.userRpointTemplates = [] as any;
                for (let item of _data["userRpointTemplates"])
                    this.userRpointTemplates!.push(UserRpointTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PointTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PointTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seriesNumber"] = this.seriesNumber;
        if (Array.isArray(this.userRpointTemplates)) {
            data["userRpointTemplates"] = [];
            for (let item of this.userRpointTemplates)
                data["userRpointTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPointTemplateDto {
    seriesNumber?: number;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;
}

export class UserRpointTemplateDto implements IUserRpointTemplateDto {
    text?: string;
    created?: Date;
    requestStatus?: Status;
    comments?: CommentDto[] | undefined;

    constructor(data?: IUserRpointTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.requestStatus = _data["requestStatus"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRpointTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRpointTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["requestStatus"] = this.requestStatus;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserRpointTemplateDto {
    text?: string;
    created?: Date;
    requestStatus?: Status;
    comments?: CommentDto[] | undefined;
}

export enum Status {
    Unacceptable = 0,
    Acceptable = 1,
    UnderProcessing = 2,
}

export class UserRequestTemplateDto implements IUserRequestTemplateDto {
    file?: string;
    description?: string;
    requestStatus?: Status;
    uploadedFiles?: UploadedFileDto[] | undefined;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;

    constructor(data?: IUserRequestTemplateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.file = _data["file"];
            this.description = _data["description"];
            this.requestStatus = _data["requestStatus"];
            if (Array.isArray(_data["uploadedFiles"])) {
                this.uploadedFiles = [] as any;
                for (let item of _data["uploadedFiles"])
                    this.uploadedFiles!.push(UploadedFileDto.fromJS(item));
            }
            if (Array.isArray(_data["userRpointTemplates"])) {
                this.userRpointTemplates = [] as any;
                for (let item of _data["userRpointTemplates"])
                    this.userRpointTemplates!.push(UserRpointTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserRequestTemplateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestTemplateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        data["description"] = this.description;
        data["requestStatus"] = this.requestStatus;
        if (Array.isArray(this.uploadedFiles)) {
            data["uploadedFiles"] = [];
            for (let item of this.uploadedFiles)
                data["uploadedFiles"].push(item.toJSON());
        }
        if (Array.isArray(this.userRpointTemplates)) {
            data["userRpointTemplates"] = [];
            for (let item of this.userRpointTemplates)
                data["userRpointTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUserRequestTemplateDto {
    file?: string;
    description?: string;
    requestStatus?: Status;
    uploadedFiles?: UploadedFileDto[] | undefined;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;
}

export class UploadedFileDto implements IUploadedFileDto {
    fileName?: string;

    constructor(data?: IUploadedFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): UploadedFileDto {
        data = typeof data === 'object' ? data : {};
        let result = new UploadedFileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface IUploadedFileDto {
    fileName?: string;
}

export class CreatePointCommand implements ICreatePointCommand {
    userId?: string;
    pointName!: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;

    constructor(data?: ICreatePointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.pointName = _data["pointName"];
            if (Array.isArray(_data["pointTemplates"])) {
                this.pointTemplates = [] as any;
                for (let item of _data["pointTemplates"])
                    this.pointTemplates!.push(PointTemplateDto.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["pointName"] = this.pointName;
        if (Array.isArray(this.pointTemplates)) {
            data["pointTemplates"] = [];
            for (let item of this.pointTemplates)
                data["pointTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatePointCommand {
    userId?: string;
    pointName: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
}

export class UpdatePointCommand implements IUpdatePointCommand {
    id?: string;
    pointName!: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;

    constructor(data?: IUpdatePointCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.pointName = _data["pointName"];
            if (Array.isArray(_data["pointTemplates"])) {
                this.pointTemplates = [] as any;
                for (let item of _data["pointTemplates"])
                    this.pointTemplates!.push(PointTemplateDto.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePointCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePointCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["pointName"] = this.pointName;
        if (Array.isArray(this.pointTemplates)) {
            data["pointTemplates"] = [];
            for (let item of this.pointTemplates)
                data["pointTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdatePointCommand {
    id?: string;
    pointName: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
}

export class GetPointTemplateQueryVM implements IGetPointTemplateQueryVM {
    id?: string;
    seriesNumber?: number;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;

    constructor(data?: IGetPointTemplateQueryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.seriesNumber = _data["seriesNumber"];
            if (Array.isArray(_data["userRpointTemplates"])) {
                this.userRpointTemplates = [] as any;
                for (let item of _data["userRpointTemplates"])
                    this.userRpointTemplates!.push(UserRpointTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPointTemplateQueryVM {
        data = typeof data === 'object' ? data : {};
        let result = new GetPointTemplateQueryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["seriesNumber"] = this.seriesNumber;
        if (Array.isArray(this.userRpointTemplates)) {
            data["userRpointTemplates"] = [];
            for (let item of this.userRpointTemplates)
                data["userRpointTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPointTemplateQueryVM {
    id?: string;
    seriesNumber?: number;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;
}

export class CreatePointTemplateCommand implements ICreatePointTemplateCommand {
    templateId?: string;
    pointId?: string;
    seriesNumber!: number;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;

    constructor(data?: ICreatePointTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateId = _data["templateId"];
            this.pointId = _data["pointId"];
            this.seriesNumber = _data["seriesNumber"];
            if (Array.isArray(_data["userRpointTemplates"])) {
                this.userRpointTemplates = [] as any;
                for (let item of _data["userRpointTemplates"])
                    this.userRpointTemplates!.push(UserRpointTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreatePointTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePointTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateId"] = this.templateId;
        data["pointId"] = this.pointId;
        data["seriesNumber"] = this.seriesNumber;
        if (Array.isArray(this.userRpointTemplates)) {
            data["userRpointTemplates"] = [];
            for (let item of this.userRpointTemplates)
                data["userRpointTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreatePointTemplateCommand {
    templateId?: string;
    pointId?: string;
    seriesNumber: number;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;
}

export class UpdatePointTemplateCommand implements IUpdatePointTemplateCommand {
    id?: string;
    seriesNumber!: number;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;

    constructor(data?: IUpdatePointTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.seriesNumber = _data["seriesNumber"];
            if (Array.isArray(_data["userRpointTemplates"])) {
                this.userRpointTemplates = [] as any;
                for (let item of _data["userRpointTemplates"])
                    this.userRpointTemplates!.push(UserRpointTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdatePointTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePointTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["seriesNumber"] = this.seriesNumber;
        if (Array.isArray(this.userRpointTemplates)) {
            data["userRpointTemplates"] = [];
            for (let item of this.userRpointTemplates)
                data["userRpointTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdatePointTemplateCommand {
    id?: string;
    seriesNumber: number;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;
}

export class GetRoleQueryVM implements IGetRoleQueryVM {
    id?: string;
    roleName?: string;
    roleSources?: RoleSource[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IGetRoleQueryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["roleSources"])) {
                this.roleSources = [] as any;
                for (let item of _data["roleSources"])
                    this.roleSources!.push(RoleSource.fromJS(item));
            }
            if (Array.isArray(_data["roleTemplates"])) {
                this.roleTemplates = [] as any;
                for (let item of _data["roleTemplates"])
                    this.roleTemplates!.push(RoleTemplate.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRoleQueryVM {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleQueryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.roleSources)) {
            data["roleSources"] = [];
            for (let item of this.roleSources)
                data["roleSources"].push(item.toJSON());
        }
        if (Array.isArray(this.roleTemplates)) {
            data["roleTemplates"] = [];
            for (let item of this.roleTemplates)
                data["roleTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRoleQueryVM {
    id?: string;
    roleName?: string;
    roleSources?: RoleSource[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRoles?: UserRole[] | undefined;
}

export abstract class BaseEntity implements IBaseEntity {
    id?: string;
    domainEvents?: BaseEvent[];

    constructor(data?: IBaseEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["domainEvents"])) {
                this.domainEvents = [] as any;
                for (let item of _data["domainEvents"])
                    this.domainEvents!.push(BaseEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): BaseEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.domainEvents)) {
            data["domainEvents"] = [];
            for (let item of this.domainEvents)
                data["domainEvents"].push(item.toJSON());
        }
        return data;
    }
}

export interface IBaseEntity {
    id?: string;
    domainEvents?: BaseEvent[];
}

export abstract class BaseAuditableEntity extends BaseEntity implements IBaseAuditableEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;

    constructor(data?: IBaseAuditableEntity) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
        }
    }

    static override fromJS(data: any): BaseAuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseAuditableEntity' cannot be instantiated.");
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        super.toJSON(data);
        return data;
    }
}

export interface IBaseAuditableEntity extends IBaseEntity {
    created?: Date;
    createdBy?: string | undefined;
    lastModified?: Date | undefined;
    lastModifiedBy?: string | undefined;
}

export class RoleSource extends BaseAuditableEntity implements IRoleSource {
    roleId?: string;
    sourceId?: string;
    role?: Role | undefined;
    source?: Source | undefined;

    constructor(data?: IRoleSource) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.roleId = _data["roleId"];
            this.sourceId = _data["sourceId"];
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : <any>undefined;
            this.source = _data["source"] ? Source.fromJS(_data["source"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): RoleSource {
        data = typeof data === 'object' ? data : {};
        let result = new RoleSource();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["sourceId"] = this.sourceId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRoleSource extends IBaseAuditableEntity {
    roleId?: string;
    sourceId?: string;
    role?: Role | undefined;
    source?: Source | undefined;
}

export class Role extends BaseAuditableEntity implements IRole {
    roleName?: string;
    roleSources?: RoleSource[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IRole) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["roleSources"])) {
                this.roleSources = [] as any;
                for (let item of _data["roleSources"])
                    this.roleSources!.push(RoleSource.fromJS(item));
            }
            if (Array.isArray(_data["roleTemplates"])) {
                this.roleTemplates = [] as any;
                for (let item of _data["roleTemplates"])
                    this.roleTemplates!.push(RoleTemplate.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName;
        if (Array.isArray(this.roleSources)) {
            data["roleSources"] = [];
            for (let item of this.roleSources)
                data["roleSources"].push(item.toJSON());
        }
        if (Array.isArray(this.roleTemplates)) {
            data["roleTemplates"] = [];
            for (let item of this.roleTemplates)
                data["roleTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IRole extends IBaseAuditableEntity {
    roleName?: string;
    roleSources?: RoleSource[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRoles?: UserRole[] | undefined;
}

export class RoleTemplate extends BaseAuditableEntity implements IRoleTemplate {
    roleId?: string;
    templateId?: string;
    role?: Role | undefined;
    template?: Template | undefined;

    constructor(data?: IRoleTemplate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.roleId = _data["roleId"];
            this.templateId = _data["templateId"];
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : <any>undefined;
            this.template = _data["template"] ? Template.fromJS(_data["template"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): RoleTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new RoleTemplate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["templateId"] = this.templateId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IRoleTemplate extends IBaseAuditableEntity {
    roleId?: string;
    templateId?: string;
    role?: Role | undefined;
    template?: Template | undefined;
}

export class Template extends BaseAuditableEntity implements ITemplate {
    templateName?: string;
    description?: string;
    coverImage?: string;
    pointTemplates?: PointTemplate[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRequestTemplates?: UserRequestTemplate[] | undefined;

    constructor(data?: ITemplate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.templateName = _data["templateName"];
            this.description = _data["description"];
            this.coverImage = _data["coverImage"];
            if (Array.isArray(_data["pointTemplates"])) {
                this.pointTemplates = [] as any;
                for (let item of _data["pointTemplates"])
                    this.pointTemplates!.push(PointTemplate.fromJS(item));
            }
            if (Array.isArray(_data["roleTemplates"])) {
                this.roleTemplates = [] as any;
                for (let item of _data["roleTemplates"])
                    this.roleTemplates!.push(RoleTemplate.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplate.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Template {
        data = typeof data === 'object' ? data : {};
        let result = new Template();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["description"] = this.description;
        data["coverImage"] = this.coverImage;
        if (Array.isArray(this.pointTemplates)) {
            data["pointTemplates"] = [];
            for (let item of this.pointTemplates)
                data["pointTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.roleTemplates)) {
            data["roleTemplates"] = [];
            for (let item of this.roleTemplates)
                data["roleTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ITemplate extends IBaseAuditableEntity {
    templateName?: string;
    description?: string;
    coverImage?: string;
    pointTemplates?: PointTemplate[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRequestTemplates?: UserRequestTemplate[] | undefined;
}

export class PointTemplate extends BaseAuditableEntity implements IPointTemplate {
    seriesNumber?: number;
    templateId?: string;
    pointId?: string;
    point?: Point | undefined;
    template?: Template | undefined;
    userRpointTemplates?: UserRpointTemplate[] | undefined;

    constructor(data?: IPointTemplate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.seriesNumber = _data["seriesNumber"];
            this.templateId = _data["templateId"];
            this.pointId = _data["pointId"];
            this.point = _data["point"] ? Point.fromJS(_data["point"]) : <any>undefined;
            this.template = _data["template"] ? Template.fromJS(_data["template"]) : <any>undefined;
            if (Array.isArray(_data["userRpointTemplates"])) {
                this.userRpointTemplates = [] as any;
                for (let item of _data["userRpointTemplates"])
                    this.userRpointTemplates!.push(UserRpointTemplate.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): PointTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new PointTemplate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["seriesNumber"] = this.seriesNumber;
        data["templateId"] = this.templateId;
        data["pointId"] = this.pointId;
        data["point"] = this.point ? this.point.toJSON() : <any>undefined;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        if (Array.isArray(this.userRpointTemplates)) {
            data["userRpointTemplates"] = [];
            for (let item of this.userRpointTemplates)
                data["userRpointTemplates"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IPointTemplate extends IBaseAuditableEntity {
    seriesNumber?: number;
    templateId?: string;
    pointId?: string;
    point?: Point | undefined;
    template?: Template | undefined;
    userRpointTemplates?: UserRpointTemplate[] | undefined;
}

export class Point extends BaseAuditableEntity implements IPoint {
    userId?: string;
    pointName?: string;
    pointTemplates?: PointTemplate[] | undefined;
    userRequestTemplates?: UserRequestTemplate[] | undefined;
    user?: User | undefined;

    constructor(data?: IPoint) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.pointName = _data["pointName"];
            if (Array.isArray(_data["pointTemplates"])) {
                this.pointTemplates = [] as any;
                for (let item of _data["pointTemplates"])
                    this.pointTemplates!.push(PointTemplate.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplate.fromJS(item));
            }
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): Point {
        data = typeof data === 'object' ? data : {};
        let result = new Point();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["pointName"] = this.pointName;
        if (Array.isArray(this.pointTemplates)) {
            data["pointTemplates"] = [];
            for (let item of this.pointTemplates)
                data["pointTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IPoint extends IBaseAuditableEntity {
    userId?: string;
    pointName?: string;
    pointTemplates?: PointTemplate[] | undefined;
    userRequestTemplates?: UserRequestTemplate[] | undefined;
    user?: User | undefined;
}

export class UserRequestTemplate extends BaseAuditableEntity implements IUserRequestTemplate {
    file?: string;
    description?: string;
    userId?: string;
    templateId?: string;
    pointId?: string;
    sourceId?: string;
    requestStatus?: Status;
    user?: User | undefined;
    template?: Template | undefined;
    point?: Point | undefined;
    source?: Source | undefined;
    uploadedFiles?: UploadedFile[] | undefined;
    userRpointTemplates?: UserRpointTemplate[] | undefined;

    constructor(data?: IUserRequestTemplate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.file = _data["file"];
            this.description = _data["description"];
            this.userId = _data["userId"];
            this.templateId = _data["templateId"];
            this.pointId = _data["pointId"];
            this.sourceId = _data["sourceId"];
            this.requestStatus = _data["requestStatus"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.template = _data["template"] ? Template.fromJS(_data["template"]) : <any>undefined;
            this.point = _data["point"] ? Point.fromJS(_data["point"]) : <any>undefined;
            this.source = _data["source"] ? Source.fromJS(_data["source"]) : <any>undefined;
            if (Array.isArray(_data["uploadedFiles"])) {
                this.uploadedFiles = [] as any;
                for (let item of _data["uploadedFiles"])
                    this.uploadedFiles!.push(UploadedFile.fromJS(item));
            }
            if (Array.isArray(_data["userRpointTemplates"])) {
                this.userRpointTemplates = [] as any;
                for (let item of _data["userRpointTemplates"])
                    this.userRpointTemplates!.push(UserRpointTemplate.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): UserRequestTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new UserRequestTemplate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["file"] = this.file;
        data["description"] = this.description;
        data["userId"] = this.userId;
        data["templateId"] = this.templateId;
        data["pointId"] = this.pointId;
        data["sourceId"] = this.sourceId;
        data["requestStatus"] = this.requestStatus;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["template"] = this.template ? this.template.toJSON() : <any>undefined;
        data["point"] = this.point ? this.point.toJSON() : <any>undefined;
        data["source"] = this.source ? this.source.toJSON() : <any>undefined;
        if (Array.isArray(this.uploadedFiles)) {
            data["uploadedFiles"] = [];
            for (let item of this.uploadedFiles)
                data["uploadedFiles"].push(item.toJSON());
        }
        if (Array.isArray(this.userRpointTemplates)) {
            data["userRpointTemplates"] = [];
            for (let item of this.userRpointTemplates)
                data["userRpointTemplates"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUserRequestTemplate extends IBaseAuditableEntity {
    file?: string;
    description?: string;
    userId?: string;
    templateId?: string;
    pointId?: string;
    sourceId?: string;
    requestStatus?: Status;
    user?: User | undefined;
    template?: Template | undefined;
    point?: Point | undefined;
    source?: Source | undefined;
    uploadedFiles?: UploadedFile[] | undefined;
    userRpointTemplates?: UserRpointTemplate[] | undefined;
}

export class User extends BaseAuditableEntity implements IUser {
    firstName?: string;
    lastName?: string;
    email?: string;
    password?: string;
    points?: Point[] | undefined;
    comments?: Comment[] | undefined;
    userRequestTemplates?: UserRequestTemplate[] | undefined;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IUser) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            if (Array.isArray(_data["points"])) {
                this.points = [] as any;
                for (let item of _data["points"])
                    this.points!.push(Point.fromJS(item));
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplate.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        if (Array.isArray(this.points)) {
            data["points"] = [];
            for (let item of this.points)
                data["points"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUser extends IBaseAuditableEntity {
    firstName?: string;
    lastName?: string;
    email?: string;
    password?: string;
    points?: Point[] | undefined;
    comments?: Comment[] | undefined;
    userRequestTemplates?: UserRequestTemplate[] | undefined;
    userRoles?: UserRole[] | undefined;
}

export class Comment extends BaseAuditableEntity implements IComment {
    text?: string;
    commentDate?: Date;
    userId?: string;
    commentId?: string;
    userRpointTemplateId?: string;
    user?: User | undefined;
    commentNavigation?: Comment | undefined;
    userRpointTemplate?: UserRpointTemplate | undefined;
    inverseCommentNavigation?: Comment[] | undefined;

    constructor(data?: IComment) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.text = _data["text"];
            this.commentDate = _data["commentDate"] ? new Date(_data["commentDate"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.commentId = _data["commentId"];
            this.userRpointTemplateId = _data["userRpointTemplateId"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
            this.commentNavigation = _data["commentNavigation"] ? Comment.fromJS(_data["commentNavigation"]) : <any>undefined;
            this.userRpointTemplate = _data["userRpointTemplate"] ? UserRpointTemplate.fromJS(_data["userRpointTemplate"]) : <any>undefined;
            if (Array.isArray(_data["inverseCommentNavigation"])) {
                this.inverseCommentNavigation = [] as any;
                for (let item of _data["inverseCommentNavigation"])
                    this.inverseCommentNavigation!.push(Comment.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Comment {
        data = typeof data === 'object' ? data : {};
        let result = new Comment();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["commentDate"] = this.commentDate ? this.commentDate.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["commentId"] = this.commentId;
        data["userRpointTemplateId"] = this.userRpointTemplateId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["commentNavigation"] = this.commentNavigation ? this.commentNavigation.toJSON() : <any>undefined;
        data["userRpointTemplate"] = this.userRpointTemplate ? this.userRpointTemplate.toJSON() : <any>undefined;
        if (Array.isArray(this.inverseCommentNavigation)) {
            data["inverseCommentNavigation"] = [];
            for (let item of this.inverseCommentNavigation)
                data["inverseCommentNavigation"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IComment extends IBaseAuditableEntity {
    text?: string;
    commentDate?: Date;
    userId?: string;
    commentId?: string;
    userRpointTemplateId?: string;
    user?: User | undefined;
    commentNavigation?: Comment | undefined;
    userRpointTemplate?: UserRpointTemplate | undefined;
    inverseCommentNavigation?: Comment[] | undefined;
}

export class UserRpointTemplate extends BaseAuditableEntity implements IUserRpointTemplate {
    text?: string;
    created?: Date;
    userRequestTemplateId?: string;
    pointTemplateId?: string;
    requestStatus?: Status;
    pointTemplate?: PointTemplate | undefined;
    userRequestTemplate?: UserRequestTemplate | undefined;
    comments?: Comment[] | undefined;

    constructor(data?: IUserRpointTemplate) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.text = _data["text"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.userRequestTemplateId = _data["userRequestTemplateId"];
            this.pointTemplateId = _data["pointTemplateId"];
            this.requestStatus = _data["requestStatus"];
            this.pointTemplate = _data["pointTemplate"] ? PointTemplate.fromJS(_data["pointTemplate"]) : <any>undefined;
            this.userRequestTemplate = _data["userRequestTemplate"] ? UserRequestTemplate.fromJS(_data["userRequestTemplate"]) : <any>undefined;
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(Comment.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): UserRpointTemplate {
        data = typeof data === 'object' ? data : {};
        let result = new UserRpointTemplate();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["userRequestTemplateId"] = this.userRequestTemplateId;
        data["pointTemplateId"] = this.pointTemplateId;
        data["requestStatus"] = this.requestStatus;
        data["pointTemplate"] = this.pointTemplate ? this.pointTemplate.toJSON() : <any>undefined;
        data["userRequestTemplate"] = this.userRequestTemplate ? this.userRequestTemplate.toJSON() : <any>undefined;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface IUserRpointTemplate extends IBaseAuditableEntity {
    text?: string;
    created?: Date;
    userRequestTemplateId?: string;
    pointTemplateId?: string;
    requestStatus?: Status;
    pointTemplate?: PointTemplate | undefined;
    userRequestTemplate?: UserRequestTemplate | undefined;
    comments?: Comment[] | undefined;
}

export abstract class BaseEvent implements IBaseEvent {

    constructor(data?: IBaseEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): BaseEvent {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEvent' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IBaseEvent {
}

export class UserRole extends BaseAuditableEntity implements IUserRole {
    userId?: string;
    roleId?: string;
    role?: Role | undefined;
    user?: User | undefined;

    constructor(data?: IUserRole) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
            this.role = _data["role"] ? Role.fromJS(_data["role"]) : <any>undefined;
            this.user = _data["user"] ? User.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IUserRole extends IBaseAuditableEntity {
    userId?: string;
    roleId?: string;
    role?: Role | undefined;
    user?: User | undefined;
}

export class Source extends BaseAuditableEntity implements ISource {
    sourceName?: string;
    roleSources?: RoleSource[] | undefined;
    userRequestTemplates?: UserRequestTemplate[] | undefined;

    constructor(data?: ISource) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.sourceName = _data["sourceName"];
            if (Array.isArray(_data["roleSources"])) {
                this.roleSources = [] as any;
                for (let item of _data["roleSources"])
                    this.roleSources!.push(RoleSource.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplate.fromJS(item));
            }
        }
    }

    static override fromJS(data: any): Source {
        data = typeof data === 'object' ? data : {};
        let result = new Source();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceName"] = this.sourceName;
        if (Array.isArray(this.roleSources)) {
            data["roleSources"] = [];
            for (let item of this.roleSources)
                data["roleSources"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        super.toJSON(data);
        return data;
    }
}

export interface ISource extends IBaseAuditableEntity {
    sourceName?: string;
    roleSources?: RoleSource[] | undefined;
    userRequestTemplates?: UserRequestTemplate[] | undefined;
}

export class UploadedFile extends BaseAuditableEntity implements IUploadedFile {
    fileName?: string;
    userRequestTemplateId?: string;
    userRequestTemplate?: UserRequestTemplate | undefined;

    constructor(data?: IUploadedFile) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileName = _data["fileName"];
            this.userRequestTemplateId = _data["userRequestTemplateId"];
            this.userRequestTemplate = _data["userRequestTemplate"] ? UserRequestTemplate.fromJS(_data["userRequestTemplate"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): UploadedFile {
        data = typeof data === 'object' ? data : {};
        let result = new UploadedFile();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["userRequestTemplateId"] = this.userRequestTemplateId;
        data["userRequestTemplate"] = this.userRequestTemplate ? this.userRequestTemplate.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IUploadedFile extends IBaseAuditableEntity {
    fileName?: string;
    userRequestTemplateId?: string;
    userRequestTemplate?: UserRequestTemplate | undefined;
}

export class CreateRoleCommand implements ICreateRoleCommand {
    roleName!: string;
    roleSources?: RoleSource[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRoles?: UserRole[] | undefined;

    constructor(data?: ICreateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["roleSources"])) {
                this.roleSources = [] as any;
                for (let item of _data["roleSources"])
                    this.roleSources!.push(RoleSource.fromJS(item));
            }
            if (Array.isArray(_data["roleTemplates"])) {
                this.roleTemplates = [] as any;
                for (let item of _data["roleTemplates"])
                    this.roleTemplates!.push(RoleTemplate.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName;
        if (Array.isArray(this.roleSources)) {
            data["roleSources"] = [];
            for (let item of this.roleSources)
                data["roleSources"].push(item.toJSON());
        }
        if (Array.isArray(this.roleTemplates)) {
            data["roleTemplates"] = [];
            for (let item of this.roleTemplates)
                data["roleTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateRoleCommand {
    roleName: string;
    roleSources?: RoleSource[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRoles?: UserRole[] | undefined;
}

export class UpdateRoleCommand implements IUpdateRoleCommand {
    id?: string;
    roleName!: string;
    roleSources?: RoleSource[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IUpdateRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["roleSources"])) {
                this.roleSources = [] as any;
                for (let item of _data["roleSources"])
                    this.roleSources!.push(RoleSource.fromJS(item));
            }
            if (Array.isArray(_data["roleTemplates"])) {
                this.roleTemplates = [] as any;
                for (let item of _data["roleTemplates"])
                    this.roleTemplates!.push(RoleTemplate.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.roleSources)) {
            data["roleSources"] = [];
            for (let item of this.roleSources)
                data["roleSources"].push(item.toJSON());
        }
        if (Array.isArray(this.roleTemplates)) {
            data["roleTemplates"] = [];
            for (let item of this.roleTemplates)
                data["roleTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateRoleCommand {
    id?: string;
    roleName: string;
    roleSources?: RoleSource[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRoles?: UserRole[] | undefined;
}

export class CreateRoleSourceCommand implements ICreateRoleSourceCommand {
    roleId?: string;
    sourceId?: string;

    constructor(data?: ICreateRoleSourceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.sourceId = _data["sourceId"];
        }
    }

    static fromJS(data: any): CreateRoleSourceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleSourceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["sourceId"] = this.sourceId;
        return data;
    }
}

export interface ICreateRoleSourceCommand {
    roleId?: string;
    sourceId?: string;
}

export class CreateRoleTemplateCommand implements ICreateRoleTemplateCommand {
    roleId?: string;
    templateId?: string;

    constructor(data?: ICreateRoleTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.templateId = _data["templateId"];
        }
    }

    static fromJS(data: any): CreateRoleTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateRoleTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["templateId"] = this.templateId;
        return data;
    }
}

export interface ICreateRoleTemplateCommand {
    roleId?: string;
    templateId?: string;
}

export class GetSourceQueryVM implements IGetSourceQueryVM {
    id?: string;
    sourceName?: string;
    roleSources?: RoleSource[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;

    constructor(data?: IGetSourceQueryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sourceName = _data["sourceName"];
            if (Array.isArray(_data["roleSources"])) {
                this.roleSources = [] as any;
                for (let item of _data["roleSources"])
                    this.roleSources!.push(RoleSource.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSourceQueryVM {
        data = typeof data === 'object' ? data : {};
        let result = new GetSourceQueryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceName"] = this.sourceName;
        if (Array.isArray(this.roleSources)) {
            data["roleSources"] = [];
            for (let item of this.roleSources)
                data["roleSources"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetSourceQueryVM {
    id?: string;
    sourceName?: string;
    roleSources?: RoleSource[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
}

export class CreateSourceCommand implements ICreateSourceCommand {
    sourceName!: string;
    roleSources?: RoleSource[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;

    constructor(data?: ICreateSourceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceName = _data["sourceName"];
            if (Array.isArray(_data["roleSources"])) {
                this.roleSources = [] as any;
                for (let item of _data["roleSources"])
                    this.roleSources!.push(RoleSource.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateSourceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateSourceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceName"] = this.sourceName;
        if (Array.isArray(this.roleSources)) {
            data["roleSources"] = [];
            for (let item of this.roleSources)
                data["roleSources"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateSourceCommand {
    sourceName: string;
    roleSources?: RoleSource[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
}

export class UpdateSourceCommand implements IUpdateSourceCommand {
    id?: string;
    sourceName!: string;
    roleSources?: RoleSource[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;

    constructor(data?: IUpdateSourceCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.sourceName = _data["sourceName"];
            if (Array.isArray(_data["roleSources"])) {
                this.roleSources = [] as any;
                for (let item of _data["roleSources"])
                    this.roleSources!.push(RoleSource.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateSourceCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSourceCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["sourceName"] = this.sourceName;
        if (Array.isArray(this.roleSources)) {
            data["roleSources"] = [];
            for (let item of this.roleSources)
                data["roleSources"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateSourceCommand {
    id?: string;
    sourceName: string;
    roleSources?: RoleSource[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
}

export class GetTemplateQueryVM implements IGetTemplateQueryVM {
    id?: string;
    templateName?: string;
    description?: string;
    coverImage?: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;

    constructor(data?: IGetTemplateQueryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateName = _data["templateName"];
            this.description = _data["description"];
            this.coverImage = _data["coverImage"];
            if (Array.isArray(_data["pointTemplates"])) {
                this.pointTemplates = [] as any;
                for (let item of _data["pointTemplates"])
                    this.pointTemplates!.push(PointTemplateDto.fromJS(item));
            }
            if (Array.isArray(_data["roleTemplates"])) {
                this.roleTemplates = [] as any;
                for (let item of _data["roleTemplates"])
                    this.roleTemplates!.push(RoleTemplate.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTemplateQueryVM {
        data = typeof data === 'object' ? data : {};
        let result = new GetTemplateQueryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateName"] = this.templateName;
        data["description"] = this.description;
        data["coverImage"] = this.coverImage;
        if (Array.isArray(this.pointTemplates)) {
            data["pointTemplates"] = [];
            for (let item of this.pointTemplates)
                data["pointTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.roleTemplates)) {
            data["roleTemplates"] = [];
            for (let item of this.roleTemplates)
                data["roleTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTemplateQueryVM {
    id?: string;
    templateName?: string;
    description?: string;
    coverImage?: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
}

export class CreateTemplateCommand implements ICreateTemplateCommand {
    templateName!: string;
    description!: string;
    coverImage!: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;

    constructor(data?: ICreateTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.templateName = _data["templateName"];
            this.description = _data["description"];
            this.coverImage = _data["coverImage"];
            if (Array.isArray(_data["pointTemplates"])) {
                this.pointTemplates = [] as any;
                for (let item of _data["pointTemplates"])
                    this.pointTemplates!.push(PointTemplateDto.fromJS(item));
            }
            if (Array.isArray(_data["roleTemplates"])) {
                this.roleTemplates = [] as any;
                for (let item of _data["roleTemplates"])
                    this.roleTemplates!.push(RoleTemplate.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["templateName"] = this.templateName;
        data["description"] = this.description;
        data["coverImage"] = this.coverImage;
        if (Array.isArray(this.pointTemplates)) {
            data["pointTemplates"] = [];
            for (let item of this.pointTemplates)
                data["pointTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.roleTemplates)) {
            data["roleTemplates"] = [];
            for (let item of this.roleTemplates)
                data["roleTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateTemplateCommand {
    templateName: string;
    description: string;
    coverImage: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
}

export class UpdateTemplateCommand implements IUpdateTemplateCommand {
    id?: string;
    templateName!: string;
    description!: string;
    coverImage!: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;

    constructor(data?: IUpdateTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.templateName = _data["templateName"];
            this.description = _data["description"];
            this.coverImage = _data["coverImage"];
            if (Array.isArray(_data["pointTemplates"])) {
                this.pointTemplates = [] as any;
                for (let item of _data["pointTemplates"])
                    this.pointTemplates!.push(PointTemplateDto.fromJS(item));
            }
            if (Array.isArray(_data["roleTemplates"])) {
                this.roleTemplates = [] as any;
                for (let item of _data["roleTemplates"])
                    this.roleTemplates!.push(RoleTemplate.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["templateName"] = this.templateName;
        data["description"] = this.description;
        data["coverImage"] = this.coverImage;
        if (Array.isArray(this.pointTemplates)) {
            data["pointTemplates"] = [];
            for (let item of this.pointTemplates)
                data["pointTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.roleTemplates)) {
            data["roleTemplates"] = [];
            for (let item of this.roleTemplates)
                data["roleTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateTemplateCommand {
    id?: string;
    templateName: string;
    description: string;
    coverImage: string;
    pointTemplates?: PointTemplateDto[] | undefined;
    roleTemplates?: RoleTemplate[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
}

export class GetFileQueryVM implements IGetFileQueryVM {
    id?: string;
    fileName?: string;

    constructor(data?: IGetFileQueryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): GetFileQueryVM {
        data = typeof data === 'object' ? data : {};
        let result = new GetFileQueryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface IGetFileQueryVM {
    id?: string;
    fileName?: string;
}

export class CreateFileCommand implements ICreateFileCommand {
    fileName!: string;

    constructor(data?: ICreateFileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): CreateFileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface ICreateFileCommand {
    fileName: string;
}

export class UpdateFileCommand implements IUpdateFileCommand {
    id?: string;
    fileName!: string;

    constructor(data?: IUpdateFileCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileName = _data["fileName"];
        }
    }

    static fromJS(data: any): UpdateFileCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateFileCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileName"] = this.fileName;
        return data;
    }
}

export interface IUpdateFileCommand {
    id?: string;
    fileName: string;
}

export class GetUserQueryVM implements IGetUserQueryVM {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    password?: string;
    comments?: CommentDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IGetUserQueryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDto.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserQueryVM {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserQueryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUserQueryVM {
    id?: string;
    firstName?: string;
    lastName?: string;
    email?: string;
    password?: string;
    comments?: CommentDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
    userRoles?: UserRole[] | undefined;
}

export class CreateUserCommand implements ICreateUserCommand {
    firstName!: string;
    lastName!: string;
    email!: string;
    password!: string;
    comments?: CommentDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
    userRoles?: UserRoleDto[] | undefined;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDto.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRoleDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateUserCommand {
    firstName: string;
    lastName: string;
    email: string;
    password: string;
    comments?: CommentDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
    userRoles?: UserRoleDto[] | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    userId?: string;
    roleId?: string;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface IUserRoleDto {
    userId?: string;
    roleId?: string;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    id?: string;
    firstName!: string;
    lastName!: string;
    email!: string;
    password!: string;
    comments?: CommentDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
    userRoles?: UserRole[] | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.password = _data["password"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDto.fromJS(item));
            }
            if (Array.isArray(_data["userRequestTemplates"])) {
                this.userRequestTemplates = [] as any;
                for (let item of _data["userRequestTemplates"])
                    this.userRequestTemplates!.push(UserRequestTemplateDto.fromJS(item));
            }
            if (Array.isArray(_data["userRoles"])) {
                this.userRoles = [] as any;
                for (let item of _data["userRoles"])
                    this.userRoles!.push(UserRole.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["password"] = this.password;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.userRequestTemplates)) {
            data["userRequestTemplates"] = [];
            for (let item of this.userRequestTemplates)
                data["userRequestTemplates"].push(item.toJSON());
        }
        if (Array.isArray(this.userRoles)) {
            data["userRoles"] = [];
            for (let item of this.userRoles)
                data["userRoles"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateUserCommand {
    id?: string;
    firstName: string;
    lastName: string;
    email: string;
    password: string;
    comments?: CommentDto[] | undefined;
    userRequestTemplates?: UserRequestTemplateDto[] | undefined;
    userRoles?: UserRole[] | undefined;
}

export class GetUserRequestTemplateQueryVM implements IGetUserRequestTemplateQueryVM {
    id?: string;
    file?: string;
    description?: string;
    requestStatus?: Status;
    uploadedFiles?: UploadedFileDto[] | undefined;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;

    constructor(data?: IGetUserRequestTemplateQueryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.file = _data["file"];
            this.description = _data["description"];
            this.requestStatus = _data["requestStatus"];
            if (Array.isArray(_data["uploadedFiles"])) {
                this.uploadedFiles = [] as any;
                for (let item of _data["uploadedFiles"])
                    this.uploadedFiles!.push(UploadedFileDto.fromJS(item));
            }
            if (Array.isArray(_data["userRpointTemplates"])) {
                this.userRpointTemplates = [] as any;
                for (let item of _data["userRpointTemplates"])
                    this.userRpointTemplates!.push(UserRpointTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserRequestTemplateQueryVM {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserRequestTemplateQueryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["file"] = this.file;
        data["description"] = this.description;
        data["requestStatus"] = this.requestStatus;
        if (Array.isArray(this.uploadedFiles)) {
            data["uploadedFiles"] = [];
            for (let item of this.uploadedFiles)
                data["uploadedFiles"].push(item.toJSON());
        }
        if (Array.isArray(this.userRpointTemplates)) {
            data["userRpointTemplates"] = [];
            for (let item of this.userRpointTemplates)
                data["userRpointTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUserRequestTemplateQueryVM {
    id?: string;
    file?: string;
    description?: string;
    requestStatus?: Status;
    uploadedFiles?: UploadedFileDto[] | undefined;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;
}

export class CreateUserRequestTemplateCommand implements ICreateUserRequestTemplateCommand {
    userId?: string;
    templateId?: string;
    pointId?: string;
    sourceId?: string;
    file!: string;
    description!: string;
    requestStatus?: Status;
    uploadedFiles?: UploadedFileDto[] | undefined;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;

    constructor(data?: ICreateUserRequestTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.templateId = _data["templateId"];
            this.pointId = _data["pointId"];
            this.sourceId = _data["sourceId"];
            this.file = _data["file"];
            this.description = _data["description"];
            this.requestStatus = _data["requestStatus"];
            if (Array.isArray(_data["uploadedFiles"])) {
                this.uploadedFiles = [] as any;
                for (let item of _data["uploadedFiles"])
                    this.uploadedFiles!.push(UploadedFileDto.fromJS(item));
            }
            if (Array.isArray(_data["userRpointTemplates"])) {
                this.userRpointTemplates = [] as any;
                for (let item of _data["userRpointTemplates"])
                    this.userRpointTemplates!.push(UserRpointTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateUserRequestTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRequestTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["templateId"] = this.templateId;
        data["pointId"] = this.pointId;
        data["sourceId"] = this.sourceId;
        data["file"] = this.file;
        data["description"] = this.description;
        data["requestStatus"] = this.requestStatus;
        if (Array.isArray(this.uploadedFiles)) {
            data["uploadedFiles"] = [];
            for (let item of this.uploadedFiles)
                data["uploadedFiles"].push(item.toJSON());
        }
        if (Array.isArray(this.userRpointTemplates)) {
            data["userRpointTemplates"] = [];
            for (let item of this.userRpointTemplates)
                data["userRpointTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateUserRequestTemplateCommand {
    userId?: string;
    templateId?: string;
    pointId?: string;
    sourceId?: string;
    file: string;
    description: string;
    requestStatus?: Status;
    uploadedFiles?: UploadedFileDto[] | undefined;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;
}

export class UpdateUserRequestTemplateCommand implements IUpdateUserRequestTemplateCommand {
    id?: string;
    file!: string;
    description!: string;
    requestStatus?: Status;
    uploadedFiles?: UploadedFileDto[] | undefined;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;

    constructor(data?: IUpdateUserRequestTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.file = _data["file"];
            this.description = _data["description"];
            this.requestStatus = _data["requestStatus"];
            if (Array.isArray(_data["uploadedFiles"])) {
                this.uploadedFiles = [] as any;
                for (let item of _data["uploadedFiles"])
                    this.uploadedFiles!.push(UploadedFileDto.fromJS(item));
            }
            if (Array.isArray(_data["userRpointTemplates"])) {
                this.userRpointTemplates = [] as any;
                for (let item of _data["userRpointTemplates"])
                    this.userRpointTemplates!.push(UserRpointTemplateDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateUserRequestTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRequestTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["file"] = this.file;
        data["description"] = this.description;
        data["requestStatus"] = this.requestStatus;
        if (Array.isArray(this.uploadedFiles)) {
            data["uploadedFiles"] = [];
            for (let item of this.uploadedFiles)
                data["uploadedFiles"].push(item.toJSON());
        }
        if (Array.isArray(this.userRpointTemplates)) {
            data["userRpointTemplates"] = [];
            for (let item of this.userRpointTemplates)
                data["userRpointTemplates"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateUserRequestTemplateCommand {
    id?: string;
    file: string;
    description: string;
    requestStatus?: Status;
    uploadedFiles?: UploadedFileDto[] | undefined;
    userRpointTemplates?: UserRpointTemplateDto[] | undefined;
}

export class CreateUserRoleCommand implements ICreateUserRoleCommand {
    userId?: string;
    roleId?: string;

    constructor(data?: ICreateUserRoleCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.roleId = _data["roleId"];
        }
    }

    static fromJS(data: any): CreateUserRoleCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRoleCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        return data;
    }
}

export interface ICreateUserRoleCommand {
    userId?: string;
    roleId?: string;
}

export class GetUserRpointTemplateQueryVM implements IGetUserRpointTemplateQueryVM {
    id?: string;
    text?: string;
    created?: Date;
    requestStatus?: Status;
    comments?: CommentDto[] | undefined;

    constructor(data?: IGetUserRpointTemplateQueryVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.requestStatus = _data["requestStatus"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserRpointTemplateQueryVM {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserRpointTemplateQueryVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["requestStatus"] = this.requestStatus;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUserRpointTemplateQueryVM {
    id?: string;
    text?: string;
    created?: Date;
    requestStatus?: Status;
    comments?: CommentDto[] | undefined;
}

export class CreateUserRpointTemplateCommand implements ICreateUserRpointTemplateCommand {
    userRequestTemplateId?: string;
    pointTemplateId?: string;
    text!: string;
    created!: Date;
    requestStatus?: Status;
    comments?: CommentDto[] | undefined;

    constructor(data?: ICreateUserRpointTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRequestTemplateId = _data["userRequestTemplateId"];
            this.pointTemplateId = _data["pointTemplateId"];
            this.text = _data["text"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.requestStatus = _data["requestStatus"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateUserRpointTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRpointTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRequestTemplateId"] = this.userRequestTemplateId;
        data["pointTemplateId"] = this.pointTemplateId;
        data["text"] = this.text;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["requestStatus"] = this.requestStatus;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateUserRpointTemplateCommand {
    userRequestTemplateId?: string;
    pointTemplateId?: string;
    text: string;
    created: Date;
    requestStatus?: Status;
    comments?: CommentDto[] | undefined;
}

export class UpdateUserRpointTemplateCommand implements IUpdateUserRpointTemplateCommand {
    id?: string;
    text!: string;
    created!: Date;
    requestStatus?: Status;
    comments?: CommentDto[] | undefined;

    constructor(data?: IUpdateUserRpointTemplateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.requestStatus = _data["requestStatus"];
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(CommentDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateUserRpointTemplateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserRpointTemplateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["requestStatus"] = this.requestStatus;
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateUserRpointTemplateCommand {
    id?: string;
    text: string;
    created: Date;
    requestStatus?: Status;
    comments?: CommentDto[] | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}